<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Chess</title>
    <link rel="stylesheet" href="chess.css">
    <script src="chess.js"></script>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>

    <div id="errors" style="
      background: #c00;
      color: #fff;
      display: none;
      margin: -20px -20px 20px;
      padding: 20px;
      white-space: pre-wrap;
    "></div>

    <div id="root"></div>

    <script type="text/babel">
      
      window.addEventListener('mousedown', function(e) {
        document.body.classList.add('mouse-navigation');
        document.body.classList.remove('kbd-navigation');
      });
      window.addEventListener('keydown', function(e) {
        if (e.keyCode === 9) {
          document.body.classList.add('kbd-navigation');
          document.body.classList.remove('mouse-navigation');
        }
      });
      window.addEventListener('click', function(e) {
        if (e.target.tagName === 'A' && e.target.getAttribute('href') === '#') {
          e.preventDefault();
        }
      });
      window.onerror = function(message, source, line, col, error) {
        var text = error ? error.stack || error : message + ' (at ' + source + ':' + line + ':' + col + ')';
        errors.textContent += text + '\n';
        errors.style.display = '';
      };
      console.error = (function(old) {
        return function error() {
          errors.textContent += Array.prototype.slice.call(arguments).join(' ') + '\n';
          errors.style.display = '';
          old.apply(this, arguments);
        }
      })(console.error);

      // ##################################################
      // React components
      // ##################################################

      class PawnPromotionModal extends React.Component {
        render() {
          if (!this.props.show) {
            return null;
          }
          const pawnPromotionChoicesJsx = Chess.PAWN_PROMOTION_CHOICES.map((choice, index) => {
            let piece = new Chess.Piece(choice, this.props.color);
            return (
              <PawnPromotionChoice 
                piece={piece}
                onClick={() => this.props.onClick(piece)}
                key={"pawn-promotion-choice-" + index}
                id={this.props.position}
              />
            );
          });
            
          return (
            <div className="backdrop">
              <div className="modal">
                {pawnPromotionChoicesJsx}
              </div>
            </div>
          );
        }
      }

      class PawnPromotionChoice extends React.Component {
        render() {
          return (
            <button className={"pawn-promotion-choice"} onClick={this.props.onClick}>
              <Piece 
                type={this.props.piece.type} 
                color={this.props.piece.color} 
                id={this.props.id} 
                draggable={false} 
              />
            </button>
          );
        }
      }

      class Piece extends React.Component {

        constructor(props) {
          super(props);
          this.drag = this.drag.bind(this);
        }

        drag(e) {
          e.dataTransfer.setData("text", e.target.id);
          this.props.onDrag();
        }

        render() {
          return (
            <div>
              <img src={Chess.findPieceImgName(this.props.type, this.props.color)} className="piece" draggable={this.props.draggable} onDragStart={this.drag} id={this.props.id} />
            </div>
          );
        }
      }
      
      class Square extends React.Component {

        constructor(props) {
          super(props);
          this.drop = this.drop.bind(this);
        }

        drop(e) {
          e.preventDefault();
          var data = e.dataTransfer.getData("text");
          this.props.onDrop();
        }

        allowDrop(e) {
          e.preventDefault();
        }

        render() {
          const selected = this.props.isSelected ? " selected" : "";
          const value = 
            this.props.value 
            ? <Piece 
                type={this.props.value.type} 
                color={this.props.value.color} 
                id={this.props.id} 
                draggable={this.props.currentPlayer === this.props.value.color} 
                onDrag={this.props.onDrag}
              /> 
            : this.props.value;
          return (
            <button className={"square" + selected} onClick={this.props.onClick} onDrop={this.drop} onDragOver={this.allowDrop}>
              {value}
            </button>
          );
        }
      }

      class Board extends React.Component {
        renderSquare(i) {
          return (
            <Square
              value={this.props.squares[i]}
              key={"square-" + i}
              onClick={() => this.props.onClick(i)}
              isSelected={this.props.selectedSquare === i}
              onDrop={() => this.props.onDrop(i)}
              onDrag={() => this.props.onDrag(i)}
              currentPlayer={this.props.currentPlayer}
              id={"" + i}
            />
          );
        }

        render() {
          const board = [];
          for (let row = 0; row < Chess.NUM_ROWS; row++) {
            let rowSquares = [];
            for (let col = 0; col < Chess.NUM_COLS; col++) {
              let position = row * Chess.NUM_ROWS + col;
              rowSquares.push(this.renderSquare(position));
            }
            board.push(
              <div className="board-row" key={"board-row-" + row}>
                {rowSquares}
              </div>
            );
          }
          return (
            <div>
              {board}
            </div>
          );
        }
      }
      
      class Game extends React.Component {
        constructor() {
          super();
          this.state = {
            squares: Chess.createInitialSquares(),
            selectedSquare: null,
            currentPlayer: Chess.ColorEnum.WHITE,
            previousMoves: [],
          };
        }

        handleClick(i) {
          const squares = this.state.squares.slice();
          const previousMoves = this.state.previousMoves.slice();
          const selectedSquare = this.state.selectedSquare;
          // todo: retrieve valid moves here?
          if (selectedSquare !== null) {
            // Piece has already been selected. Current selection indicates where the piece should be moved
            if (Chess.isValidMove(selectedSquare, i, squares, previousMoves)) {
              // todo if opponent captured
              if (Chess.isEnPassantMove(selectedSquare, i, squares, previousMoves)) {
                squares[Chess.findEnPassantPieceToCapture(i, this.state.currentPlayer)] = null;
              }
              if (Chess.isCastlingMove(selectedSquare, i, squares, previousMoves)) {
                const rookStart = Chess.findCastlingRookStartPosition(selectedSquare, i, squares);
                const rookEnd = Chess.findCastlingRookEndPosition(selectedSquare, i, squares);
                squares[rookEnd] = squares[rookStart];
                squares[rookStart] = null;
              }
              squares[i] = squares[selectedSquare];
              squares[selectedSquare] = null;
              const move = [selectedSquare, i];
              previousMoves.push(move);
              this.setState({
                squares: squares,
                selectedSquare: null,
                currentPlayer: Chess.findNextPlayer(this.state.currentPlayer),
                previousMoves: previousMoves,
              });
            } else {
              this.setState({
                selectedSquare: null,
              });
            }
          } else if (squares[i] && squares[i].color === this.state.currentPlayer) {
            // piece has been selected 
            if (!Chess.hasValidMoves(i, squares, previousMoves)) {
              return;
            }
            this.setState({
              selectedSquare: i,
            });
          }
        }

        //handleMove(oldPosition, newPosition, squares, previousMoves) {
        //  const color = squares[oldPosition].color;
        //  if (Chess.isValidMove(oldPosition, newPosition, squares, previousMoves)) {
        //    // todo if opponent captured
        //    if (Chess.isEnPassantMove(oldPosition, newPosition, squares, previousMoves)) {
        //      squares[Chess.findEnPassantPieceToCapture(newPosition, color)] = null;
        //    }
        //    if (Chess.isCastlingMove(oldPosition, newPosition, squares, previousMoves)) {
        //      const rookStart = Chess.findCastlingRookStartPosition(oldPosition, newPosition, squares);
        //      const rookEnd = Chess.findCastlingRookEndPosition(oldPosition, newPosition, squares);
        //      squares[rookEnd] = squares[rookStart];
        //      squares[rookStart] = null;
        //    }
        //    squares[newPosition] = squares[oldPosition];
        //    squares[oldPosition] = null;
        //    const move = [oldPosition, newPosition];
        //    previousMoves.push(move);
        //    this.setState({
        //      squares: squares,
        //      selectedSquare: null,
        //      currentPlayer: Chess.findNextPlayer(color),
        //      previousMoves: previousMoves,
        //    });
        //  } else {
        //    this.setState({
        //      selectedSquare: null,
        //    });
        //  }
        //}

        handleDrop(position) {
          this.handleClick(position);
        }

        handleDrag(position) {
          this.setState({
            selectedSquare: position,
          });
        }

        handlePawnPromotionClick(position, piece) {
          const squares = this.state.squares.slice();
          squares[position] = piece;
          this.setState({
            squares: squares,
          });
        }

        render() {
          const squares = this.state.squares.slice();
          const previousMoves = this.state.previousMoves.slice();
          let displayText;
          if (Chess.isCheckmate(this.state.currentPlayer, squares, previousMoves)) {
            const winner = Chess.findNextPlayer(this.state.currentPlayer);
            displayText = "Winner: " + Chess.ColorEnum.properties[winner].name;
          } else {
            displayText = "Turn: " + Chess.ColorEnum.properties[this.state.currentPlayer].name;
          }

          const previousMoveEndSquare = previousMoves.length > 0 ? previousMoves[previousMoves.length - 1][1] : -1

          return (
            <div className="game">
              <div className="game-board">
                <Board
                  squares={squares}
                  onClick={i => this.handleClick(i)}
                  selectedSquare={this.state.selectedSquare}
                  onDrop={position => this.handleDrop(position)}
                  onDrag={position => this.handleDrag(position)}
                  currentPlayer={this.state.currentPlayer}
                />
              </div>
              <div className="game-info">
                <div>{displayText}</div>
              </div>
              <div className="pawn-promo-modal">
                <PawnPromotionModal 
                  position={previousMoveEndSquare}
                  onClick={piece => this.handlePawnPromotionClick(previousMoveEndSquare, piece)}
                  show={Chess.isPawnPromotion(previousMoveEndSquare, squares)}
                  color={Chess.findNextPlayer(this.state.currentPlayer)}
                />
              </div>
            </div>
          );
        }
      }
      
      // ========================================
      
      ReactDOM.render(<Game />, document.getElementById("root"));

    </script>
  </body>
</html>
